// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using Phosphor;
//
//    var selection = Selection.FromJson(jsonString);
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace Phosphor
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class Selection
    {
        [JsonPropertyName("IcoMoonType")]
        public string IcoMoonType { get; set; }

        [JsonPropertyName("icons")]
        public List<IconElement> Icons { get; set; }

        [JsonPropertyName("height")]
        public long Height { get; set; }

        [JsonPropertyName("metadata")]
        public SelectionMetadata Metadata { get; set; }

        [JsonPropertyName("preferences")]
        public Preferences Preferences { get; set; }
    }

    public partial class IconElement
    {
        [JsonPropertyName("icon")]
        public IconIcon Icon { get; set; }

        [JsonPropertyName("attrs")]
        public List<Attr> Attrs { get; set; }

        [JsonPropertyName("properties")]
        public Properties Properties { get; set; }

        [JsonPropertyName("setIdx")]
        public long SetIdx { get; set; }

        [JsonPropertyName("setId")]
        public long SetId { get; set; }

        [JsonPropertyName("iconIdx")]
        public long IconIdx { get; set; }
    }

    public partial class Attr
    {
        [JsonPropertyName("fill")]
        public Fill Fill { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("opacity")]
        public double? Opacity { get; set; }
    }

    public partial class IconIcon
    {
        [JsonPropertyName("paths")]
        public List<string> Paths { get; set; }

        [JsonPropertyName("grid")]
        public long Grid { get; set; }

        [JsonPropertyName("attrs")]
        public List<Attr> Attrs { get; set; }

        [JsonPropertyName("isMulticolor")]
        public bool IsMulticolor { get; set; }

        [JsonPropertyName("isMulticolor2")]
        public bool IsMulticolor2 { get; set; }

        [JsonPropertyName("tags")]
        public List<string> Tags { get; set; }

        [JsonPropertyName("colorPermutations")]
        public ColorPermutations ColorPermutations { get; set; }
    }

    public partial class ColorPermutations
    {
        [JsonPropertyName("16868681")]
        public List<The16868681> The16868681 { get; set; }
    }

    public partial class The16868681
    {
        [JsonPropertyName("f")]
        public long F { get; set; }
    }

    public partial class Properties
    {
        [JsonPropertyName("id")]
        public long Id { get; set; }

        [JsonPropertyName("order")]
        public long Order { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("code")]
        public long Code { get; set; }

        [JsonPropertyName("prevSize")]
        public long PrevSize { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("codes")]
        public List<long> Codes { get; set; }
    }

    public partial class SelectionMetadata
    {
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("url")]
        public Uri Url { get; set; }

        [JsonPropertyName("designer")]
        public string Designer { get; set; }

        [JsonPropertyName("designerURL")]
        public Uri DesignerUrl { get; set; }

        [JsonPropertyName("license")]
        public string License { get; set; }

        [JsonPropertyName("licenseURL")]
        public Uri LicenseUrl { get; set; }
    }

    public partial class Preferences
    {
        [JsonPropertyName("showGlyphs")]
        public bool ShowGlyphs { get; set; }

        [JsonPropertyName("showCodes")]
        public bool ShowCodes { get; set; }

        [JsonPropertyName("showQuickUse")]
        public bool ShowQuickUse { get; set; }

        [JsonPropertyName("showQuickUse2")]
        public bool ShowQuickUse2 { get; set; }

        [JsonPropertyName("showSVGs")]
        public bool ShowSvGs { get; set; }

        [JsonPropertyName("fontPref")]
        public FontPref FontPref { get; set; }

        [JsonPropertyName("imagePref")]
        public ImagePref ImagePref { get; set; }

        [JsonPropertyName("height")]
        public long Height { get; set; }

        [JsonPropertyName("historySize")]
        public long HistorySize { get; set; }

        [JsonPropertyName("gridSize")]
        public long GridSize { get; set; }

        [JsonPropertyName("showLiga")]
        public bool ShowLiga { get; set; }
    }

    public partial class FontPref
    {
        [JsonPropertyName("prefix")]
        public string Prefix { get; set; }

        [JsonPropertyName("metadata")]
        public FontPrefMetadata Metadata { get; set; }

        [JsonPropertyName("metrics")]
        public Metrics Metrics { get; set; }

        [JsonPropertyName("embed")]
        public bool Embed { get; set; }

        [JsonPropertyName("noie8")]
        public bool Noie8 { get; set; }

        [JsonPropertyName("ie7")]
        public bool Ie7 { get; set; }

        [JsonPropertyName("includeMetadata")]
        public bool IncludeMetadata { get; set; }

        [JsonPropertyName("flutter")]
        public bool Flutter { get; set; }

        [JsonPropertyName("showSelector")]
        public bool ShowSelector { get; set; }

        [JsonPropertyName("selector")]
        public string Selector { get; set; }

        [JsonPropertyName("classSelector")]
        public string ClassSelector { get; set; }

        [JsonPropertyName("showMetrics")]
        public bool ShowMetrics { get; set; }

        [JsonPropertyName("showMetadata")]
        public bool ShowMetadata { get; set; }

        [JsonPropertyName("showVersion")]
        public bool ShowVersion { get; set; }
    }

    public partial class FontPrefMetadata
    {
        [JsonPropertyName("fontFamily")]
        public string FontFamily { get; set; }

        [JsonPropertyName("majorVersion")]
        public long MajorVersion { get; set; }

        [JsonPropertyName("minorVersion")]
        public long MinorVersion { get; set; }

        [JsonPropertyName("fontURL")]
        public Uri FontUrl { get; set; }

        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("copyright")]
        public string Copyright { get; set; }

        [JsonPropertyName("designer")]
        public string Designer { get; set; }

        [JsonPropertyName("designerURL")]
        public Uri DesignerUrl { get; set; }

        [JsonPropertyName("license")]
        public string License { get; set; }

        [JsonPropertyName("licenseURL")]
        public Uri LicenseUrl { get; set; }
    }

    public partial class Metrics
    {
        [JsonPropertyName("emSize")]
        public long EmSize { get; set; }

        [JsonPropertyName("baseline")]
        public double Baseline { get; set; }

        [JsonPropertyName("whitespace")]
        public long Whitespace { get; set; }
    }

    public partial class ImagePref
    {
        [JsonPropertyName("prefix")]
        public string Prefix { get; set; }

        [JsonPropertyName("png")]
        public bool Png { get; set; }

        [JsonPropertyName("useClassSelector")]
        public bool UseClassSelector { get; set; }

        [JsonPropertyName("color")]
        public long Color { get; set; }

        [JsonPropertyName("bgColor")]
        public long BgColor { get; set; }

        [JsonPropertyName("classSelector")]
        public string ClassSelector { get; set; }
    }

    public enum Fill { Rgb686868 };

    public partial class Selection
    {
        public static Selection FromJson(string json) => JsonSerializer.Deserialize<Selection>(json, Phosphor.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Selection self) => JsonSerializer.Serialize(self, Phosphor.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                FillConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class FillConverter : JsonConverter<Fill>
    {
        public override bool CanConvert(Type t) => t == typeof(Fill);

        public override Fill Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            if (value == "rgb(68, 68, 68)")
            {
                return Fill.Rgb686868;
            }
            throw new Exception("Cannot unmarshal type Fill");
        }

        public override void Write(Utf8JsonWriter writer, Fill value, JsonSerializerOptions options)
        {
            if (value == Fill.Rgb686868)
            {
                JsonSerializer.Serialize(writer, "rgb(68, 68, 68)", options);
                return;
            }
            throw new Exception("Cannot marshal type Fill");
        }

        public static readonly FillConverter Singleton = new FillConverter();
    }
    
    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
                this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                var value = reader.GetString();
                return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
                => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
                get => _dateTimeStyles;
                set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
                get => _dateTimeFormat ?? string.Empty;
                set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
                get => _culture ?? CultureInfo.CurrentCulture;
                set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
                string text;


                if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                        || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
                {
                        value = value.ToUniversalTime();
                }

                text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

                writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
                string? dateText = reader.GetString();

                if (string.IsNullOrEmpty(dateText) == false)
                {
                        if (!string.IsNullOrEmpty(_dateTimeFormat))
                        {
                                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                        }
                        else
                        {
                                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                        }
                }
                else
                {
                        return default(DateTimeOffset);
                }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
